# Net-Swift Orchestrator: System Knowledge Base (Generated by Cascade)
# Version: 3.0

## 1. Overall Architecture

The system is a distributed application composed of three primary, decoupled services:

1.  **Backend Orchestrator (`backend/app.py`):** A powerful Flask API server that acts as the brain of the operation. It handles all network device interactions, manages a persistent database, and serves as the single point of contact for the frontend.
2.  **Frontend UI Server (`frontend_py/app.py`):** A lightweight Flask application whose sole purposes are to serve the HTML/JavaScript user interface and to act as a secure, authenticated proxy for all requests heading to the Backend Orchestrator.
3.  **AI Microservice (`backend_mock/mock_ai_service.py`):** A Flask service running on port 5004 that provides mock AI capabilities for development and testing, including configuration analysis and RAG queries.

This architecture is robust, scalable, and secure. It separates concerns effectively, allowing each component to be developed and maintained independently.

---

## 2. Component Deep Dive

### A. Backend Orchestrator (`backend/app.py`)

-   **Core Function:** A Flask API server that exposes the platform's core capabilities.
-   **Device Inventory:** Manages a static dictionary (`DEVICE_INVENTORY`) of network devices, their connection details, and credentials.
-   **Lazy Loading:** Brilliantly uses a `_lazy_import_network_libs` function to defer loading heavy libraries like `netmiko`, `napalm`, and `pyats` until they are first used. This dramatically reduces application startup time.
-   **Multi-Vendor Abstraction:** Provides distinct functions (`retrieve_config_netmiko`, `retrieve_config_napalm`, `retrieve_config_pyats`) to interact with network devices, allowing it to use the best tool for each task.
-   **Persistence:** Utilizes a local **SQLite database** (`network_automation.db`) to store configuration backups and job history, ensuring data is not lost between restarts.
-   **API Endpoints:**
    -   `/api/devices`: Manages device inventory.
    -   `/api/config/retrieve`: Fetches configurations using a specified method.
    -   `/api/backups`: Manages historical configuration backups.
    -   `/api/ai/*`: A set of proxy endpoints that securely forward requests to the AI microservice via the `AIAgentClient`.

### B. AI Microservice Client (`backend/services/ai_agent_client.py`)

-   **Role:** An **Adapter** that encapsulates all communication with the external AI microservice.
-   **Robustness:** Implements comprehensive error handling with `try...except` blocks, connection timeouts, and status code checks (`raise_for_status`). This prevents AI service failures from crashing the main backend.
-   **Configuration:** Intelligently configures the AI service URL from the `AI_AGENT_URL` environment variable, with a sensible default (`http://127.0.0.1:5004`).
-   **Methods:** Provides clean, simple methods (`check_health`, `query_rag`, `analyze_config`) that abstract away the underlying HTTP requests.

### C. Frontend UI Server (`frontend_py/app.py`)

-   **Dual Role:** Acts as both a web server for the UI and a secure **API Proxy**.
-   **User Authentication:** Manages user login, registration, and logout. It uses a `@login_required` decorator to protect all application pages.
-   **Authenticated Proxy (`api_request`):** All requests from the UI to the backend are routed through this central function. It automatically attaches the user's authentication token (stored in the Flask session) to the `Authorization` header of every request, ensuring secure communication. This is a critical security feature.

### D. Frontend UI Template (`frontend_py/templates/devices.html`)

-   **Dynamic Rendering:** Uses Jinja2 templating to dynamically build the Device Manager page from data supplied by the Frontend UI Server.
-   **Interactive UI:** Contains vanilla JavaScript to handle user interactions like adding/deleting devices and toggling their status.
-   **AI Feature Logic:**
    -   **Event-Driven:** AI interactions are triggered by button clicks (`.ai-action-btn`).
    -   **Two-Step Analysis:** The "Analyze Config" feature is a clever two-step process:
        1.  First, it calls the `/api/config/retrieve` endpoint to fetch the device's live running configuration.
        2.  Second, it sends that configuration text to the `/api/ai/analyze_config` endpoint for analysis.
    -   **RAG Interface:** The "Ask AI" feature dynamically creates a user interface within a modal, allowing users to submit free-form questions to the RAG endpoint.

---

## 3. Known Issues & Investigation Log

### 3.1 Critical: Mock AI Service Startup Failure

-   **RESOLVED:** The `mock_ai_service.py` startup issue has been fixed. The service now starts reliably using the following command:
    ```sh
    cd /Users/macbook/GENAI-33-LOVEAB/net-swift-orchestrator && python backend_mock/mock_ai_service.py
    ```
-   **Solution:** Running the service directly in a dedicated terminal window ensures it remains active and responsive.
-   **Verification:** The service can be verified using `curl http://127.0.0.1:5004/health` which returns `{"status":"ok"}`.
-   **Next Step:** Attempt to launch the service using `nohup` to create a truly detached and persistent background process.
